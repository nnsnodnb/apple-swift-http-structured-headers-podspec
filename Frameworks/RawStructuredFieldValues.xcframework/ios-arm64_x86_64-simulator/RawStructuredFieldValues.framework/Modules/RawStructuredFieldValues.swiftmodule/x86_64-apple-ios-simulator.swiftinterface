// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.7.2 (swiftlang-5.7.2.135.5 clang-1400.0.29.51)
// swift-module-flags: -target x86_64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name RawStructuredFieldValues
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Darwin
import Swift
import _Concurrency
import _StringProcessing
public enum ItemOrInnerList : Swift.Sendable {
  case item(RawStructuredFieldValues.Item)
  case innerList(RawStructuredFieldValues.InnerList)
}
extension RawStructuredFieldValues.ItemOrInnerList : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: RawStructuredFieldValues.ItemOrInnerList, b: RawStructuredFieldValues.ItemOrInnerList) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public enum BareItem : Swift.Sendable {
  case bool(Swift.Bool)
  case integer(Swift.Int)
  case decimal(RawStructuredFieldValues.PseudoDecimal)
  case string(Swift.String)
  case undecodedByteSequence(Swift.String)
  case token(Swift.String)
}
extension RawStructuredFieldValues.BareItem : Swift.ExpressibleByBooleanLiteral {
  public init(booleanLiteral value: Swift.Bool)
  public typealias BooleanLiteralType = Swift.Bool
}
extension RawStructuredFieldValues.BareItem : Swift.ExpressibleByIntegerLiteral {
  public init(integerLiteral value: Swift.Int)
  public typealias IntegerLiteralType = Swift.Int
}
extension RawStructuredFieldValues.BareItem : Swift.ExpressibleByFloatLiteral {
  public init(floatLiteral value: Swift.Float64)
  public typealias FloatLiteralType = Swift.Float64
}
extension RawStructuredFieldValues.BareItem : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.StringLiteralType)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
}
extension RawStructuredFieldValues.BareItem : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: RawStructuredFieldValues.BareItem, b: RawStructuredFieldValues.BareItem) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct Item : Swift.Sendable {
  public var bareItem: RawStructuredFieldValues.BareItem
  public var parameters: RawStructuredFieldValues.OrderedMap<Swift.String, RawStructuredFieldValues.BareItem>
  public init(bareItem: RawStructuredFieldValues.BareItem, parameters: RawStructuredFieldValues.OrderedMap<Swift.String, RawStructuredFieldValues.BareItem>)
}
extension RawStructuredFieldValues.Item : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: RawStructuredFieldValues.Item, b: RawStructuredFieldValues.Item) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct BareInnerList : Swift.Hashable, Swift.Sendable {
  public init()
  public mutating func append(_ item: RawStructuredFieldValues.Item)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: RawStructuredFieldValues.BareInnerList, b: RawStructuredFieldValues.BareInnerList) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension RawStructuredFieldValues.BareInnerList : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: RawStructuredFieldValues.Item...)
  public typealias ArrayLiteralElement = RawStructuredFieldValues.Item
}
extension RawStructuredFieldValues.BareInnerList : Swift.RandomAccessCollection, Swift.MutableCollection {
  public struct Index {
  }
  public var count: Swift.Int {
    get
  }
  public var startIndex: RawStructuredFieldValues.BareInnerList.Index {
    get
  }
  public var endIndex: RawStructuredFieldValues.BareInnerList.Index {
    get
  }
  public func index(after i: RawStructuredFieldValues.BareInnerList.Index) -> RawStructuredFieldValues.BareInnerList.Index
  public func index(before i: RawStructuredFieldValues.BareInnerList.Index) -> RawStructuredFieldValues.BareInnerList.Index
  public func index(_ i: RawStructuredFieldValues.BareInnerList.Index, offsetBy offset: Swift.Int) -> RawStructuredFieldValues.BareInnerList.Index
  public subscript(index: RawStructuredFieldValues.BareInnerList.Index) -> RawStructuredFieldValues.Item {
    get
    set
  }
  public typealias Element = RawStructuredFieldValues.Item
  public typealias Indices = Swift.DefaultIndices<RawStructuredFieldValues.BareInnerList>
  public typealias Iterator = Swift.IndexingIterator<RawStructuredFieldValues.BareInnerList>
  public typealias SubSequence = Swift.Slice<RawStructuredFieldValues.BareInnerList>
}
extension RawStructuredFieldValues.BareInnerList.Index : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: RawStructuredFieldValues.BareInnerList.Index, b: RawStructuredFieldValues.BareInnerList.Index) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension RawStructuredFieldValues.BareInnerList.Index : Swift.Comparable {
  public static func < (lhs: RawStructuredFieldValues.BareInnerList.Index, rhs: RawStructuredFieldValues.BareInnerList.Index) -> Swift.Bool
}
public struct InnerList : Swift.Hashable, Swift.Sendable {
  public var bareInnerList: RawStructuredFieldValues.BareInnerList
  public var parameters: RawStructuredFieldValues.OrderedMap<Swift.String, RawStructuredFieldValues.BareItem>
  public init(bareInnerList: RawStructuredFieldValues.BareInnerList, parameters: RawStructuredFieldValues.OrderedMap<Swift.String, RawStructuredFieldValues.BareItem>)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: RawStructuredFieldValues.InnerList, b: RawStructuredFieldValues.InnerList) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.String {
  public var structuredHeadersIsValidToken: Swift.Bool {
    get
  }
}
public struct StructuredHeaderError : Swift.Error, Swift.Sendable {
}
extension RawStructuredFieldValues.StructuredHeaderError {
  public static let invalidTrailingBytes: RawStructuredFieldValues.StructuredHeaderError
  public static let invalidInnerList: RawStructuredFieldValues.StructuredHeaderError
  public static let invalidItem: RawStructuredFieldValues.StructuredHeaderError
  public static let invalidKey: RawStructuredFieldValues.StructuredHeaderError
  public static let invalidIntegerOrDecimal: RawStructuredFieldValues.StructuredHeaderError
  public static let invalidString: RawStructuredFieldValues.StructuredHeaderError
  public static let invalidByteSequence: RawStructuredFieldValues.StructuredHeaderError
  public static let invalidBoolean: RawStructuredFieldValues.StructuredHeaderError
  public static let invalidToken: RawStructuredFieldValues.StructuredHeaderError
  public static let invalidList: RawStructuredFieldValues.StructuredHeaderError
  public static let invalidDictionary: RawStructuredFieldValues.StructuredHeaderError
  public static let missingKey: RawStructuredFieldValues.StructuredHeaderError
  public static let invalidTypeForItem: RawStructuredFieldValues.StructuredHeaderError
  public static let integerOutOfRange: RawStructuredFieldValues.StructuredHeaderError
  public static let indexOutOfRange: RawStructuredFieldValues.StructuredHeaderError
}
extension RawStructuredFieldValues.StructuredHeaderError : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: RawStructuredFieldValues.StructuredHeaderError, b: RawStructuredFieldValues.StructuredHeaderError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension RawStructuredFieldValues.StructuredHeaderError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct StructuredFieldValueParser<BaseData> where BaseData : Swift.RandomAccessCollection, BaseData.Element == Swift.UInt8 {
  public init(_ data: BaseData)
}
extension RawStructuredFieldValues.StructuredFieldValueParser : Swift.Sendable where BaseData : Swift.Sendable, BaseData.SubSequence : Swift.Sendable {
}
extension RawStructuredFieldValues.StructuredFieldValueParser {
  public typealias BareItem = RawStructuredFieldValues.BareItem
  public typealias Item = RawStructuredFieldValues.Item
  public typealias BareInnerList = RawStructuredFieldValues.BareInnerList
  public typealias InnerList = RawStructuredFieldValues.InnerList
  public typealias ItemOrInnerList = RawStructuredFieldValues.ItemOrInnerList
  public typealias Key = Swift.String
  public mutating func parseListFieldValue() throws -> [RawStructuredFieldValues.StructuredFieldValueParser<BaseData>.ItemOrInnerList]
  public mutating func parseDictionaryFieldValue() throws -> RawStructuredFieldValues.OrderedMap<RawStructuredFieldValues.StructuredFieldValueParser<BaseData>.Key, RawStructuredFieldValues.StructuredFieldValueParser<BaseData>.ItemOrInnerList>
  public mutating func parseItemFieldValue() throws -> RawStructuredFieldValues.StructuredFieldValueParser<BaseData>.Item
}
public struct StructuredFieldValueSerializer : Swift.Sendable {
  public init()
}
extension RawStructuredFieldValues.StructuredFieldValueSerializer {
  public mutating func writeDictionaryFieldValue(_ root: RawStructuredFieldValues.OrderedMap<Swift.String, RawStructuredFieldValues.ItemOrInnerList>) throws -> [Swift.UInt8]
  public mutating func writeListFieldValue(_ list: [RawStructuredFieldValues.ItemOrInnerList]) throws -> [Swift.UInt8]
  public mutating func writeItemFieldValue(_ item: RawStructuredFieldValues.Item) throws -> [Swift.UInt8]
}
public struct OrderedMap<Key, Value> where Key : Swift.Hashable {
  public init()
  public subscript(key: Key) -> Value? {
    get
    set
  }
}
extension RawStructuredFieldValues.OrderedMap : Swift.Sendable where Key : Swift.Sendable, Value : Swift.Sendable {
}
extension RawStructuredFieldValues.OrderedMap : Swift.RandomAccessCollection, Swift.MutableCollection {
  public struct Index : Swift.Sendable {
  }
  public var startIndex: RawStructuredFieldValues.OrderedMap<Key, Value>.Index {
    get
  }
  public var endIndex: RawStructuredFieldValues.OrderedMap<Key, Value>.Index {
    get
  }
  public var count: Swift.Int {
    get
  }
  public subscript(position: RawStructuredFieldValues.OrderedMap<Key, Value>.Index) -> (Key, Value) {
    get
    set
  }
  public func index(_ i: RawStructuredFieldValues.OrderedMap<Key, Value>.Index, offsetBy distance: Swift.Int) -> RawStructuredFieldValues.OrderedMap<Key, Value>.Index
  public func index(after i: RawStructuredFieldValues.OrderedMap<Key, Value>.Index) -> RawStructuredFieldValues.OrderedMap<Key, Value>.Index
  public func index(before i: RawStructuredFieldValues.OrderedMap<Key, Value>.Index) -> RawStructuredFieldValues.OrderedMap<Key, Value>.Index
  public typealias Element = (Key, Value)
  public typealias Indices = Swift.Range<RawStructuredFieldValues.OrderedMap<Key, Value>.Index>
  public typealias Iterator = Swift.IndexingIterator<RawStructuredFieldValues.OrderedMap<Key, Value>>
  public typealias SubSequence = Swift.Slice<RawStructuredFieldValues.OrderedMap<Key, Value>>
}
extension RawStructuredFieldValues.OrderedMap.Index : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension RawStructuredFieldValues.OrderedMap.Index : Swift.Comparable {
  public static func < (lhs: RawStructuredFieldValues.OrderedMap<Key, Value>.Index, rhs: RawStructuredFieldValues.OrderedMap<Key, Value>.Index) -> Swift.Bool
}
extension RawStructuredFieldValues.OrderedMap.Index : Swift.Strideable {
  public func advanced(by n: Swift.Int) -> RawStructuredFieldValues.OrderedMap<Key, Value>.Index
  public func distance(to other: RawStructuredFieldValues.OrderedMap<Key, Value>.Index) -> Swift.Int
  public typealias Stride = Swift.Int
}
extension RawStructuredFieldValues.OrderedMap : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Key, Value)...)
}
extension RawStructuredFieldValues.OrderedMap : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension RawStructuredFieldValues.OrderedMap : Swift.Equatable where Value : Swift.Equatable {
  public static func == (a: RawStructuredFieldValues.OrderedMap<Key, Value>, b: RawStructuredFieldValues.OrderedMap<Key, Value>) -> Swift.Bool
}
extension RawStructuredFieldValues.OrderedMap : Swift.Hashable where Value : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct PseudoDecimal : Swift.Hashable, Swift.Sendable {
  public var mantissa: Swift.Int64 {
    get
    set
  }
  public var exponent: Swift.Int8 {
    get
    set
  }
  public init(mantissa: Swift.Int, exponent: Swift.Int)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: RawStructuredFieldValues.PseudoDecimal, b: RawStructuredFieldValues.PseudoDecimal) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension RawStructuredFieldValues.PseudoDecimal : Swift.ExpressibleByFloatLiteral {
  public init(_ value: Swift.Double) throws
  public init(floatLiteral value: Swift.Double)
  public typealias FloatLiteralType = Swift.Double
}
extension Swift.String {
  public init(_ decimal: RawStructuredFieldValues.PseudoDecimal)
}
extension Swift.Double {
  public init(_ pseudoDecimal: RawStructuredFieldValues.PseudoDecimal)
}
